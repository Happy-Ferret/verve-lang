type BigObject {
  BigObject(String, String, String, String, String, String, String, String) // 8 Strings
}

type Pair {
  Pair(Int, Int)
}

type Wrapper {
  Wrapper(Pair)
}

fn allocate() -> BigObject {
  BigObject(
    "foooooooooooooooooooooooooooooooooooooooooooo",
    "foooooooooooooooooooooooooooooooooooooooooooo",
    "foooooooooooooooooooooooooooooooooooooooooooo",
    "foooooooooooooooooooooooooooooooooooooooooooo",
    "foooooooooooooooooooooooooooooooooooooooooooo",
    "foooooooooooooooooooooooooooooooooooooooooooo",
    "foooooooooooooooooooooooooooooooooooooooooooo",
    "foooooooooooooooooooooooooooooooooooooooooooo"
  )
}

fn a() -> BigObject { allocate() allocate() }
fn b() -> BigObject { a() a() }
fn c() -> BigObject { b() b() }
fn d() -> BigObject { c() c() }
fn e() -> BigObject { d() d() }
fn f() -> BigObject { e() e() }
fn g() -> BigObject { f() f() }
fn h() -> BigObject { g() g() }
fn i() -> BigObject { h() h() }
fn j() -> BigObject { i() i() }
fn k() -> BigObject { j() j() }
fn l() -> BigObject { k() k() }
fn m() -> BigObject { l() l() }
fn n() -> BigObject { m() m() }

fn test(wrapped: Wrapper) -> Void {
  n() // allocate a lot and trigger garbage collection
  let Wrapper(pair) = wrapped {
    let Pair(a, b) = pair { 
      print([a, b])
    }
  }
}

test(Wrapper(Pair(42, 13)))

// this will allocate 4243744b (~4mb)
// the GC should get it down to ~20k
// here we just test it's less than ~30k
print(`__heap-size__`() < 30000)
